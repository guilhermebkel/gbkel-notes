# Clean Coder: A Code of Conduct for Professional Programmers

## Summary

This book gives some tips about how to be a better developer.

## Professionalism

It's a lot easier to be a nonprofessional. Nonprofessionals don't have to take responsibility for the job they do - they leave that to their employers. If a nonprofessional makes an error, the employer cleans up the mess. But when a professional makes a mistake, he clean up the mess.

Professionalism is all about taking responsibility.

### Taking Responsibility

#### Do No Harm to Function

We harm the function of our software when we create bugs. Therefore, in order to be professional, we must not create bugs.

The fact that the task to write perfect software is virtually impossible does not mean you aren't responsible for the imperfection.

It is the lot of a professional to be accountable for errors even though errors are virtually certain.

The first thing you must practice is apologizing. Apologies are necessary, but insufficient. You cannot simply keep making the same errors over and over. As you mature in your profession, your error rate should rapidly decrease towards the asymptote of zero. It won't ever get to zero, but it is your responsibility to get as close as possible to it.

**Things that can help avoiding bugs:** Automated tests, manual tests (test everything you can the maximum amount of times you are able to).

#### Do No Harm to Structure

The true professional knows that delivering function at the expense of structure is a fool's errand. It is the structure of your code that allows it to be flexible. If you compromise the structure, you compromise the future.

The fundamental assumption underlying all software projects is that software is easy to change. If you violate this assumption by creating inflexible structures, then you undercut the economic model that the entire industry is based on.

You must be able to make changes without exorbitant costs.

Since there are too many projects with poor structure, if you want your software to be flexible, you have to flex it.

The only way to prove that your software is easy to change is to make easy changes to it. And when you find that the changes aren't as easy as you thought, you refine the design so that the next change is easier.

### Work Ethic

Your career is your responsibility. It is not your employer's responsibility to make sure you are marketable. It is not your employer's responsibility to train you, or to send you to conferences, or to buy you books. These things are your responsibility.

It is also not your employer's responsibility to give you the time you need to learn.

Perhaps you don't want to make that kind of commitment of dedicating time to yourself. That's fine, but you should not then think of yourself as a professional. Professionals spend time for their profession.

#### Know Your Field

A wealth of ideas, disciplines, techniques, tools, and terminologies decorate the last fifty years of our field.

If you want to be professional, you should know a sizable chunk of it and constantly be increasing the size of that chunk.

Maybe some of the knowledge of that chunk can be irrelevant today, but be minded that who cannot remember the past are condemned to repeat it.

Below there are some stuffs every software professional should be conversant with:

- **Design patterns:** You ought to be able to describe all 24 patterns in the GOF book and have a working knowledge of many of the patterns in the POSA books.

- **Design principles:** You should know the SOLID principles and have a good understanding of the component principles.

- **Methods:** You should understand XP, Scrum, Lean, Kanban, Waterfall, Structured Analysis, and Structured Design.

- **Disciplines:** You should practice TDD, Object-Oriented design, Structured Programming, Continuous Programming, and Pair Programming.

- **Artifacts:** You should know how to use: UML, DFDs, Structure Charts, Petri Nets, State Transition Diagrams and Tables, flow charts, and decision tables.

#### Continuous Learning

Read books, articles, blogs, tweets. Go to conferences. Go to user groups. Participate in reading and study groups. Learn things that are outside your comfort zone.

#### Practice

Professionals practice. True professionals work hard to keep their skills sharp and ready. It is not enough to simply do your daily job and call that practice. Doing your daily job is performance, not practice. Practice is when you specifically exercise your skills outside of the performance of your job for the sole purpose of refining and enhancing those skills.

#### Collaboration

The second best way to learn is to collaborate with other people. Professional software developers make a special effort to program together, practice together, design and plan together.

#### Mentoring

The best way to learn is to teach. Nothing will drive facts and values into your head faster and harder than having to communicate them to people you are responsible for. So the benefit of teaching is strongly in favor of the teacher.

#### Know Your Domain

It is the responsibility of every software professional to understand the domain of the solutions they are programming. If you are writing an accounting system, you should know the accounting field.

#### Humility

Programming is an act of creation. When we write code we are creating something out of nothing. We are boldly imposing order upon chaos. We are confidently commanding, in precise detail, the behaviors of a machine that could otherwise do incalculable damage. And so, programming is an act of supreme arrogance.

Professionals know they are arrogant and are not falsely humble. A professional knows his job and takes pride in his work. A professional is confident is his abilities, and takes bold and calculated risks based on that confidence. A professional is not timid.

However, a professional also knows that there will be times he will fail, his risk calculations will be wrong, his abilities will fall short; he'll look in the mirror and see an arrogant fool smiling back at him.

So when a professional finds himself the butt of a joke, he'll be first to laugh. He will never ridicule others, but will accept ridicule when it is deserved and laugh it off when it's not. He will not demean another for making a mistake, because he knows he may be the next to fail.

A professional understands his supreme arrogance, and that the fates will eventually notice and level their aim. When that aim connects, the best you can do is take Howard's advice: Laugh.

## Saying No

When your manager tells you that the login page has to be ready by tomorrow, he is pursuing and defending one of his objectives. He is doing his job. If you know full well that getting the login page done by tomorrow is impossible, then you are not doing your job if you say **"OK, I'll try"**. The only way to do your job, at that point, is to say **"No, that's impossible"**.

But don't you have to do what your manager says? No, your manager is counting on you to defend your objectives as aggressively as he defends his. That's how the two of you are going to get to the best possible outcome.

The best possible outcome is the goal that you and your manager share.

### What about the Why?

Sometimes, explaining why the login page is going to take so much longer is less important than the fact. The fact is that the login page will require two weeks. Why it will take two weeks is just a detail. Still, knowing why might help your manager accepting the fact (in case he is a technical manager).And sometimes, providing too much detail can be an invitation for micro-management.

### High Stakes

The most important time to say no is when the stakes are highest. The higher the stakes, the more valuable no becomes.

This should be self-evident. When the cost of failure is so high that the survival of your company depends upon it, you must be absolutely determined to give your managers the best information you can, and that often means saying no.

### Being a "Team Player"

Being a team player means playing your position as well as you possibly can, and helping out your teammates when they get into a jam. A team-player communicates frequently, keeps an eye out for his or her teammates, and executes his or her own responsibilities as well as possible.

A team player is not someone who says yes all the time.

## Saying Yes

Professionals are not required to say yes to everything that is asked of them. However, they should work hard to find creative ways to make "yes" possible. When professionals say yes, they use the language of commitment so that there is no doubt about what they've promised.

### A Language of Commitment

There are three parts to making a commitment:

**1. You say you'll do it.**

**2. You mean it.**

**3. You actually do it.**

#### Recognizing Lack of Commitment

We should look at the language we use when we commit to doing something, as the tell-tale sign of things to come. Actually, it's more a matter of looking for specific words in what we way. If you can't find those little magic words, chances are we don't mean what we say, or we may not believe it to be feasible.

Some noncommitment words can be: Need/Should, Hope/Wish, Let's.

#### Issues on Commitment

- **It wouldn't work because I rely on person X to get this done:** You can only commit to things that you have full control of.

- **It wouldn't work because I don't really know if it can be done:** If it can't be done, you can still commit to actions that will bring you closer to the target.

- **It wouldn't work because sometimes I just won't make it:** That happens. Something unexpected might happen, and that's life. But you still want to live up to expectations. In that case, it's time to change the expectations, as soon as possible.

## Coding

### Preparedness

Coding is an intellectually challenging and exhausting activity. It requires a level of concentration and focus that few other disciplines require. The reason for this is that coding requires you to juggle many competing factors at one.

1. Your code must work. You must understand what problem you are solving and understand how to solve that problem. You must ensure that the code you write is a faithful representation of that solution. You must manage every detail of that solution while remaining consistent within the language, platform, current architecture, and all the warts of the current system.

2. Your code must solve the problem set for you be the customer. Often the customer's requirements do not actually solve the customer's problems. It is up to you to see this and negotiate with the customer to ensure that the customer's true needs are met.

3. Your code must fit well into the existing system. It should not increase the rigidity, fragility, or opacity of that system. The dependencies must be well-managed. In short, your code needs to follow solid engineering principles.

4. Your code must be readable by other programmers. This is not simply matter of writing nice comments. Rather, it requires that you craft the code in such a way that it reveals your intent. This is hard to do. Indeed, this may be the most difficult thing a programmer can master.

### Worry Code

Have you ever gotten into a big fight with your spouse or friend, and then tried to code? Did you notice that there was a background process running in your mind trying to resolve, or at least review the fight? Sometimes you can feel the stress of that background process in your chest, or in the pit of your stomach. It can make you feel anxious, like when you've had too much coffee or diet coke. It's distracting.

So, this is no time to code. Any code I produce will be trash. So instead of coding, you need to resolve the worry.

### The Flow Zone

It is the highly focused, tunnel-vision state of consciousness that programmers can get into while they write code. In this state, you feel productive. In this state you feel infallible. So you desire to attain that state, and often measure your self-worth by how much time can spend there.

Avoid the zone. This state of consciousness is not really hyper-productive and is certainly not infallible. It's really just a mild meditative state in which certain rational faculties are diminished in favor of a sense of speed.

The problem of Zone is that you lose some of the big picture, so you will likely make decisions that you will later have to go back and reverse.

#### Interruptions

Visualize yourself as you are coding at your workstation. How do you respond when someone asks you a question? Do you snap at them? Do you glare? Does your body-language tell them to go away because you are busy? In short, are you rude?

Or, do you stop what you are doing and politely help someone who is stuck? Do you treat them as you would have them treat you if you were stuck?

The rude response often comes from the Zone. You may resent being dragged out of the Zone, or you may resent someone interfering with your attempt to enter the Zone. Either way, the rudeness often comes from your relationship to the Zone.

### Debugging Time

For some reason software developers don't think of debugging time as coding time. They think of debugging time as a call of nature, something that just has to be done. But debugging time is just as expensive to the business as coding time is, and therefore anything we can do to avoid or diminish it is good.

### Pacing Yourself

Software development is a marathon, not a print. You can't win the race by trying to run as fast as you can from the outset. You win by conserving your resources and pacing yourself. A marathon runner takes care of her body both before and during the race. Professional programmers conserve their energy and creativity with the same care.

### Know When to Walk Away

Can't go home till you solve this problem? Oh yes you can, and you probably should! Creativity and intelligence are fleeting states of mind. When you are tired, they go away. If you then pound your nonfunctioning brain for hour after late-night hour trying to solve a problem, you'll simply make yourself more tired and reduce the chance that the shower, or the car, will help you solve the problem.

### Being Late

You will be late. It happens to the best of us. It happens to the most dedicated of us. Sometimes we just blow our estimates and wind up late.

The trick to managing lateness is early detection and transparency. The worst case scenario occurs when you continue to tell everyone, up to the very end, that you will be on time - and them let them all down. Don't do this. Instead, regularly measure your progress against your goal, and come up with three fact-based end dates: best case, nominal case, and worst case.

### Rushing

What if your manager sits you down and asks you to try to make the deadline?

There is no way to rush. You can't make yourself code faster. You can't make yourself solve problems faster. If you try, you'll just slow yourself down and make a mess that slows everyone else down, too.

### Overtime

Overtime can work, and sometimes it is necessary.

Therefore you should not agree to work overtime unless you can personally afford it, it is short term, two weeks or less, and your boss has a full-back plan in case the overtime effort fails.

### False Delivery

Of all the unprofessional behaviors that a programmer can indulge in, perhaps the worst of all is saying you are done when you know you aren't.

This is a contagious practice. If one programmer does it, others will see and follow suit.

### Define "Done"

You avoid the problem of false delivery by creating an independent definition of "done". The best way to do this is to have your business analysts and testers create automated acceptance tests that must pass before you can say that you are done.

### Helping Others

It is the responsibility of programmers to be available to help each other. It is a violation of professional ethics to sequester yourself in a cubicle or office and refuse the queries of others. Your work is not so important that you cannot lend some of your time to help others. Indeed, as a professional you are honor bound to offer that help whenever it is needed.

#### Being Helped

When someone offers to help you, be gracious about it. Accept the help gratefully and give yourself to that help.

## Practicing

All professionals practice their art by engaging in skill-sharpening exercises.

Doing anything quickly requires practice. Spinning around the code/test loop quickly requires you to make very quick decisions. Making decisions quickly means being able to recognize a vast number of situations and problems and simply know what to do to address them.

## Acceptance Testing

The role of the professional developer is a communications role as well as a development role. Remember that garbage-in/garbage-out applies to programmers too, so professional programmers are careful to make sure that their communication with other members of the team, and the business, are accurate and healthy.

### Communicating Requirements

One of the most common communication issues between programmers and business is the requirements. The business people state what they believe they need, and then the programmers build what they believe the business described. At least that's how it's supposed to work.

#### Premature Precision

Both business and programmers are tempted to fall into the trap of premature precision. Business people want to know exactly what they are going to get before they authorize a project. Developers want to know exactly what they are supposed to deliver before they estimate the project. Both sides want a precision that simply cannot be achieved, and are often willing to waste a fortune trying to attain it.

#### The Uncertainty Principle

The problem is that things appear different on paper than they do in a working system. When the business actually sees what they specified running in a system, they realize that it wasn't what they wanted at all. Once they see the requirement actually running, they have a better idea of what they really want - and it's usually not what they are seeing.

There's a kind of observer effect, or uncertainty principle, in play. When you demonstrate a feature to the business, it gives them more information than they had before, and that new information impacts how they see the whole system.

In the end, the more precise you make your requirements, the less relevant they become as the system is implemented.

#### Estimation Anxiety

Developers, too, can get caught in the precision trap. They know they must estimate the system and often think that this requires precision. It doesn't.

First, even with perfect information your estimates will have a huge variance. Second, the uncertainty principle makes hash out of early precision. The requirements will change making that precision moot.

### Late Ambiguity

The solution to premature precision is to defer precision as long as possible. Professional developers don't flesh out a requirement until they are just about to develop it. However, that can lead to another malady: late ambiguity.

### Communication

The purpose of acceptance tests is communication, clarity, and precision. By agreeing to them, the developers, stakeholders, and testers all understand what the plan for the system behavior is. Achieving this kind of clarity is the responsibility of all parties.

## Estimation

Estimation is one of the simplest, yet most frightening activities that software professionals face. So much business value depends on it. So much of our reputations ride on it. So much of our angst and failure are caused by it. It is the primary wedge that has been driven between business people and developers. It is the source of nearly all the distrust that rules that relationship.

### What is an Estimate?

The problem is that we view estimates in different ways. Business likes to view estimates as commitment. Developers like to view estimates as guesses. The difference is profound.

An estimate is a guess. No commitment is implied. No promise is made. Missing an estimate is not in any way dishonorable. The reason we make estimates is because we don't know how long something will take.

## Pressure

The best way to stay calm under pressure is to avoid situations that cause pressure. That avoidance may not eliminate the pressure completely, but it can go a long way towards minimizing and shortening the high-pressure periods.

### Staying Clean

We can avoid pressure by keeping our systems, our code, and our design as clean as possible. This does not mean that we spend endless hours polishing code. It simply means that we don't tolerate messes. We know that messes will slow us down, causing us to miss dates and break commitment. So we do the best work we can and keep our output as clean as we can.

### Crisis Discipline

You know that you believe by observing yourself in a crisis. If in a crisis you follow your disciplines, then you truly believe in those disciplines. On the other hand, if you change your behavior in a crisis, then you don't truly believe in your normal behavior.

### Don't Panic

Manage your stress. Sleepless nights won't help you get done any faster. Sitting and fretting won't help either. And the worst thing you could do is to rush! Resist that temptation at all costs. Rushing will only drive you deeper into the hole.

### Collaboration

It's good to be passionate about what we do. But it's also good to keep your eye on the goals the people who pay you.

The worst thing a professional programmer can do is to blissfully bury himself in a tomb of technology while the business crashes and burs around him. Your job is to keep the business afloat!

So, professional programmers take the time to understand the business. They talk to users about the software they are using. They talk to sales and marketing people about the problems and issues they have. They talk to managers to understand the short - and long - term goals of the team.

One of the worst symptoms of a dysfunctional team is when each programmer builds a wall around his code and refuses to let other programmers touch it.

No system should consist of code that hasn't been reviewed by other programmers.
