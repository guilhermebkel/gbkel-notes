# Pragmatic Programmer, The: From Journeyman to Master

## Summary

This book gives some tips to improve your career in the technical and personal field by a solid and practical knowledge.

## A Pragmatic Philosophy

In general, the pragmatic programmer has a different attitude, style and philosophy of approaching problems and their solution.

They think beyond the immediate problem, placing it in its larger context and seeking out the bigger picture.

They take responsibility for everything they do, what means they will not sit idly by and watch their projects fail apart through neglect.

In the end, pragmatic programming stems from a philosophy of pragmatic thinking and there are a lot of tips of how to improve on that.

### It's your life

*"I'm not in this world to live up to your expectations and you're not in this world to ive up to mine - Bruce Lee"*

Software development must appear close to the top of any list of careers where you have control and so, per example:

> If you feel like you are stagnating on your job, you can change it by studying by yourself when you are able to.
>
> If you want to work remotely, try to find a job that make you able to do that.

### It's not my problem

*"The greatest of all weaknesses is the fear of appearing weak - J.B Bossuet"*

One of the most important things about pragmatic philosophy is to take responsibility of your career advancement, your learning and education, your project, and your day-to-day work. It basically means that pragmatic programmers are not afraid to admit ignorance or error.

> Try to avoid blaming someone or something else, or make up an excuse. Don't blame all the problems on a vendor, a programming language, management, or you coworkers. Any and all of these may play a role, but it is up to you to provide solutions, not excuses.

### Software Entropy

Entropy is a term from physics that refers to the amount of disorder in a system. Some folks might call it by the more optimistic term, "technical debt", with the implied notion that they will pay it back someday. They probably will not.

There are too many factors that can contribute to software rot. The most important one seems to be the psychology, or culture, at work on a project.

That way, we can understand that hopelessness inside a project can be contagious. A common and wrong think is "All the rest of this code is crap, I will just follow suit".

> Don't leave bad designs, wrong decisions, or poor code un-repaired. Fix each one as soon as it is discovered and, if there is insufficient time to fix it properly, then board it up.
>
> Don't cause collateral damage just because there is a crisis of some sort. One broken window is one too many.

### Be a Catalyst for Change

*"People find it easier to join an ongoing success. Show them a glimpse of the future and you will get them to rally around"*

Sometimes you can be on a situation where you know exactly what need doing and how to do it, but after asking permission to tackle the whole thing you will probably be met with delays and blank stares. People will form committees, budgets will need approval, and things will get complicated. Everyone will guard their own resources.

> Work out what you can reasonably ask for. Develop it well. Once you've got it, show people, and let them marvel.
>
> Constantly review what is happening around you, not just what you personally are doing.

### Good-Enough Software

*"Striving to better, oft we mar what's well - Shakespeare"*

Usually the real world just will not let us produce much that is truly perfect, particularly not bug-free software. Time, technology, and temperature all conspire against us.

The phrase "good enough" does not imply sloppy or poorly produced code. All systems must meet they users requirements to be successful, and meet basic performance, privacy, and security standards.

> Try to put some users to test the software, because that way you will find what is the good enough software.
>
> You can discipline yourself to write software that's good enough - good enough for users, for future maintainers, for you own peace of mind. You will find that you are more productive and your users are happier.
>
> Try to make quality a requirements issue.
>
> Know when to stop, don't spoil a perfectly good program by overembellishment and overrefinement. Move on, and let your code stand in its own right for a while. It may not be perfect. Don't worry: it could never be perfect.

### Your knowledge portfolio

*"An investment in knowledge always pays the best interest - Benjamin Franklin"*

Your knowledge and experience are your most important day-to-day professional assets. Unfortunately, they are expiring assets, so, your knowledge becomes out of date as new techniques, languages, and environments are developed.

Your ability to learn new things is your most important strategic asset.

> Try to invest regularly in your knowledge portfolio by studying new topics you find to be good.
>
> Try to diversify your knowledge, because the more things you know, the more valuable you are.
>
> Critically analyze what you read and hear, try to ask "why", dig deeper, ask "why" again, and so on, till you go down some abstraction layers on a topic (Who does this benefit? What's the context? When or Where would this work? Why is this a problem?).

### Communicate

*"I believe that it is better to be looked over than it is to be overlooked - Mae West"*

As developers, we have to communicate on many levels. We spend hours in meetings, listening and talking. We work with end users, trying to understand their needs. We write code, which communicates out intentions to a machine and documents our thinking for future generations of developers. We write proposals and memos requesting and justifying resources, reporting our status, and suggesting new approaches. And we work daily within our teams to advocate our ideas, modify existing practices, and suggest new ones.

> Know your audience, you are communicating only if you are conveying what you mean to convey. So try to communicate in a way your audience understands you.
>
> Try to show your idea in a easier way to understand, by making a lot of use of drawings and even by sorting out the topic you want to talk about (introduction, development, conclusion).